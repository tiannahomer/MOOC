<?php 
/**
 * The User abstract class does two things: (i) intializes the user for the instance
 * of the application.  The default system is the default user; (ii) the init() method
 * is used to log the user into the application based on the application requirements. This
 * initialization is application-specific so the class should be specialized to handle
 * whatever specific authorization processes are required.
 * Classes that extend this abstract class should be defined in the codebase
 * directory of the application and the name of the class specified in
 * the application configuration file.  
 * 
 * @author Curtis Gittens
 * @copyright 2009-2011
 *
 */
abstract class UserAbstract
{
	/**
	 * the default user id if none is defined by the client code
	 * in the extending class. This value should work in most cases since -1 is typically
	 * not the format for user ids and is a good method for determining if the id has been set
	 */
	protected $_id = -1;			 
	
	/**
	 * Stores the data for the user as an associative array.
	 * This array must be initialized in the extending class with the variable names
	 * that the programmer wants to store on authenticated users. No data can be stored
	 * on the user until this is done.
	 */
	protected $_userdata = array();	
	
	/**
	 * Stores an error generated by the user object
	 * @var string
	 */
	protected $_usrError = '';
	protected static $_instance = null;
	
	/**
	 * Create a user singleton.
	 */
	abstract public static function getUserSingleton();
	
	
	/**
	 * This method sets all the internal data for the user
	 * and is set by a login script or some other application
	 * initialization script. The client code specifies what values
	 * should be passed to the method for initialization.
	 * @param $input	The array containing the form variables to be used for validation
	 */
	abstract public function init(array $input);
	
	
	/**
	 * Retrieve the user information that has been set by the setData 
	 * method by taking the User object and extracting its data. To retrieve
	 * multiple values, pass them as an array.
	 * @see setData()
	 * @param array|string $params The name of the variable/variables to retrieve
	 * @return mixed|array 
	 */
	public function getData($params)
	{
		$unmatchedKeys = array();
		
		if (empty($params)) {
			trigger_error('Invalid parameter sent to getData()', E_USER_ERROR);
			return;
		}
		
		// handling a string parameter
		if (is_string($params) && !isset($this->_userdata[$params])) {
			trigger_error('Property does not exist. Use viewProperties() to check available properties', E_USER_ERROR);
			return;
		}
		elseif (is_string($params) && isset($this->_userdata[$params])) {
			return $this->_userdata[$params];
		}
		
		// handling an array parameter
		if (is_array($params)) {
			// make the values sent in $params the keys of the array
			$params = array_flip($params);
			
			$unmatchedKeys = array_diff_key($params, $this->_userdata);
			if (!empty($unmatchedKeys)) {
				trigger_error('Attempting to retrieve a non-existent property value. '
							  . 'Use viewProperties() to check available properties', E_USER_ERROR);
				return;
			}
			else {
				// return the data requested
				return array_intersect_key($this->_userdata, $params);
			}
		}
	}
	
	/**
	 * Retrieve any error message generated by the user object
	 */
	public function getError()
	{
		return $this->_usrError;
	}
	
	/**
	 * Set any error messages the object may generate
	 * @param unknown_type $msg
	 */
	protected function _setError($msg)
	{
		Validator::ensureParameterIsString($msg);
		$this->_usrError = $msg;
	}
	
	/**
	 * Internal method used to set the user id. It doesn't allow
	 * empty or negative vlaues
	 * @param string $value
	 */
	protected function _setId($value)
	{
		if (empty($value) || ($value < 0)) {
			trigger_error('Invalid value used to set the member id', E_USER_ERROR);
			return;
		}
		else {
			$this->_id = $value;
			$_SESSION['user_id']=$value;
			

		}
	}
	
	
	/**
	 * Set one or more data properties in the user object. For multiple
	 * properties, pass setData an associative array, for example:
	 * <code>
	 *   // multiple values
	 *   array('var1'=>$value1, 'var2'=>$value2...)
	 *   // single value
	 *   array('var1'=>$value)
	 * </code>
	 * The variable being set has to be a valid property of the user object.
	 * To determine what properties are available for setting use {@link viewProperties}
	 * @param array $params	The variable(s) to set
	 */
	public function setData(array $params)
	{
		$unmatchedKeys = array();
		
		if (empty($params)) {
			trigger_error('Invalid parameter sent to setData()', E_USER_ERROR);
			return;
		}
		$unmatchedKeys = array_diff_key($params, $this->_userdata);
		if (!empty($unmatchedKeys)) {
			trigger_error('Attempting to set a non-existent property value. '
						  . 'Use viewProperties() to check available properties', E_USER_ERROR);
			return;
		}
		else {
			$this->_userdata = array_merge($this->_userdata, $params);
		}
	}
	
	
	/**
	 * Retrieve the unique id for the user
	 * @return string|false	The unique id of the user as a string. If no
	 * 						valid string is found, it returns false. So the
	 * 						client code should explicitly check for boolean false
	 * 						to determine if a valid user id was found
	 */
	public function getId()
	{
		return $this->_id;
	}
	
	/**
	 * Checks to see if the user id has been successfully set, i.e. changed
	 * from -1 to a non-negative, non-empty value
	 * @return true|false	True if set, false otherwise
	 */
	public function isIdSet()
	{
		if (!empty($this->_id) && ($this->_id != -1)) {

			
			
			return true;
		}
		else {
			return false;
		}
	}
	
	
	/**
	 * Displays the list of 'settable' properties for the
	 * user object
	 * @return array	An associative array containing the property name and description
	 */
	public function viewProperties()
	{
		if (!empty($this->_userdata)) {
			return array_keys($this->_userdata);
		}
	}
}
